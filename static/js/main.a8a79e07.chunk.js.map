{"version":3,"sources":["core/classes/DisjointSet.ts","core/Afd/index.ts","components/Editor/index.tsx","core/utils/index.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["DisjointSet","states","_disjoint_set","this","Set","state","push","item","s","indexOf","line","column","i","_get_index","j","filter","_item","index","Afd","grammar","grammarType","name","alphbet","productions","initialState","currentState","terminals","history","JSON","parse","_validatesProductions","_validatesInitialState","_validatesTerminals","_minimization","word","includes","head","tail","newState","undefined","length","_moveTo","run","Object","keys","find","prodState","Error","prodStates","values","reduce","combined","prog","prodSymbols","prodSymbol","map","graph","Map","key","set","value","get","stack","reachable_states","pop","has","add","fromEntries","entries","entrie","console","log","slice","_remove_unreachable_states","_addReject","table","sortedStates","sort","forEach","stateLine","stateColumn","toString","flag","parseInt","symbol","t1","t2","marked","dset","line_column","mark","split","union","finded","old_terminal","_updateProductions","print","newProductions","old_state","production","_findUnion","start","Editor","props","grammarState","setGrammar","useState","result","wordList","setWordList","listFilter","setListFilter","createAfd","window","__AFD__","obj","lines","afd_name","definition","trim","rest1","rest2","prog_name_initial","rest3","prog_name","initial","state_symbol","stringify","err","parseJSON","swal","message","InputMessage","className","HistoryMessage","lastRound","lastState","id","type","onChange","event","preventDefault","file","target","files","reader","FileReader","onloadend","readAsText","onClick","cols","rows","spellCheck","wrap","_word","e","newWord","placeholder","style","marginTop","textAlign","currenteState","simbol","text","tuple","match","parseWordTupleList","wordTuple","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a8a79e07.chunk.js","sourcesContent":["export default class DisjointSet {\n\n  _disjoint_set:Array<Array<string>>\n\n  constructor(states:Array<string>){\n    this._disjoint_set = []\n\n    if(states){\n      for(let state of new Set(states)){\n        this._disjoint_set.push([state])\n      }\n    }\n  }\n\n  protected _get_index(item:string){\n    for( let s of this._disjoint_set){\n      for( let element of s){\n        if (element === item){\n          return this._disjoint_set.indexOf(s)\n        }\n      }\n    }\n    return null\n  }\n\n  union(line:string, column:string){\n    let i = this._get_index(line)\n    let j = this._get_index(column)\n\n    if (i !== j){\n      this._disjoint_set[i] = [\n        ...this._disjoint_set[i], ...this._disjoint_set[j]\n      ]\n\n      this._disjoint_set = this._disjoint_set.filter((_item, index) => index !== j)\n    }\n  }\n\n  get(){\n    return this._disjoint_set\n  }\n}\n","import DisjointSet from '../classes/DisjointSet'\n\nexport default class Afd {\n\n  grammar: string\n  grammarType: string\n  name: string\n  states: Array<string>\n  alphbet: Array<string>\n  productions: any\n  initialState: string\n  currentState: string\n  terminals: Array<string>\n  history: Array<[string, string, string]>\n\n  constructor(grammar:string, grammarType:string = \"json\") {\n    this.grammar = grammar\n    this.grammarType = grammarType\n\n    const {\n      name,\n      states,\n      alphbet,\n      productions,\n      initialState,\n      terminals\n    } = JSON.parse(grammar)\n\n    // !AFD MINIMIZADO\n\n    this.name = name\n    this.states = states\n    this.alphbet = ['',...alphbet]\n\n    this.productions = this._validatesProductions(productions)\n    this.initialState = this._validatesInitialState(initialState)\n    this.terminals = this._validatesTerminals(terminals)\n    this.history = []\n\n    this._minimization()\n    this.currentState = initialState\n  }\n\n  run(word: string|Array<string> ):boolean{\n    // Verifica palavra vazia\n    if(!word){\n      this.history=[[this.initialState, '', this.initialState]]\n      return this.terminals.includes(this.initialState)\n    }\n\n    const [head, ...tail] = word;\n\n    const newState = this.productions[this.currentState]? this.productions[this.currentState][head] : undefined\n\n    this.history.push([this.currentState, head, newState])\n\n    if(newState){\n      /* novo estado existe */\n\n      if(tail.length !== 0){\n        /* continua a leitura da palavra */\n\n        this._moveTo( newState )\n        return this.run(tail)\n      }else {\n        /* palavra acabou, finaliza execução */\n\n        if(this.terminals.includes(newState)){\n          /* palavra pertence ao alfabeto */\n\n          this._moveTo( this.initialState )\n          return true\n        } else {\n          /* palavra não pertence ao alfabeto */\n\n          this._moveTo( this.initialState )\n          return false\n        }\n      }\n    }else {\n      /* novo estado não existe:\n         - simbolo lido não pertence ao alfabeto\n         - simbolo lido não está ligado ao estado atual\n         - estado atual não pertence ao conjunto de estados */\n      this._moveTo( this.initialState )\n      return false\n    }\n  }\n\n  protected _moveTo(state:string){\n    /* move execução para um novo estado */\n\n    this.currentState = state\n    return this.currentState\n  }\n\n  protected _validatesProductions(productions:object):object {\n\n    if(Object.keys(productions).find(prodState => !this.states.includes(prodState))) {\n      throw new Error(\"Estado da produção indefinido\")\n    }\n\n    const prodStates:Set<string> = new Set(Object\n                                            .values(productions)\n                                            .reduce((combined, prog) => [...combined, ...Object.values(prog)] ,[]))\n\n    if([...prodStates].find(prodState => !this.states.includes(prodState))){\n      throw new Error(\"Estado da produção indefinido\")\n    }\n\n    const prodSymbols:Set<string> = new Set(Object\n                                            .values(productions)\n                                            .reduce((combined, prog) => [...combined, ...Object.keys(prog)] ,[]))\n\n    if([...prodSymbols].find(prodSymbol => !this.alphbet.includes(prodSymbol))){\n      throw new Error(\"Simbolo da produção indefinido\");\n    }\n\n    return productions\n  }\n\n  protected _validatesInitialState(initialState:string){\n    if(this.states.includes(initialState)){\n      return initialState\n    }else{\n      throw new Error(\"Estado inicial não pertence ao conjunto de estados!\")\n    }\n  }\n\n  protected _validatesTerminals(terminals:Array<string>){\n    return terminals.map(state => {\n      if(this.states.includes(state)){\n        return state\n      }else {\n        throw new Error(\"Estado indefinido entre os estados terminais\")\n      }\n    })\n  }\n\n  protected _remove_unreachable_states(){\n    const graph = new Map()\n    for(const key of Object.keys(this.productions)){\n        graph.set(key, [])\n        for(const value of Object.values(this.productions[key])){\n          graph.get(key).push(value)\n        }\n    }\n    let stack = [this.initialState]\n\n    const reachable_states = new Set()\n    while(stack.length) {\n      let state = stack.pop()\n\n      if (!reachable_states.has(state) && graph.get(state)){\n        stack = [...stack, ...graph.get(state)]\n      }\n\n      reachable_states.add(state)\n    }\n    this.states = this.states.filter(state => reachable_states.has(state))\n    this.terminals = this.terminals.filter(state => reachable_states.has(state))\n    this.productions = Object.fromEntries(\n      Object.entries(this.productions)\n        .filter(entrie => reachable_states.has(entrie[0]))\n    )\n\n  }\n\n  print(){\n    console.log(\n      {\n        name: this.name,\n        states: this.states,\n        alphbet: this.alphbet,\n        productions: this.productions,\n        initialState: this.initialState,\n        terminals: this.terminals,\n      }\n    )\n  }\n\n  protected _minimization(){\n    this.alphbet = this.alphbet.slice(1)\n\n\n    this._remove_unreachable_states()\n\n    this._addReject()\n\n    const table = new Map()\n\n    const sortedStates = [...this.states].sort()\n\n    sortedStates.forEach((stateLine, index)=>{\n      const sortedTail = sortedStates.slice(index+1)\n      sortedTail.forEach(stateColumn => {\n        table.set([stateLine, stateColumn].toString(), (\n          this.terminals.includes(stateLine) !==\n          this.terminals.includes(stateColumn)\n        ))\n      })\n    })\n\n    console.log(table)\n\n    let flag = true\n\n    // método de preenchimento da tabela\n    while(flag){\n      flag = false\n\n      for(let [index, stateLine] of Object.entries(sortedStates)){\n\n        for(let stateColumn of sortedStates.slice(parseInt(index)+1)){\n          if (table.get([stateLine,stateColumn].toString())){\n            continue\n          }\n\n          // checa se os estados são distinguiveis\n          for(let symbol of this.alphbet){\n            const t1 = this.productions[stateLine][symbol]\n            const t2 = this.productions[stateColumn][symbol]\n\n            if (t1 !== t2){\n              let key = [t1,t2].sort()\n              let marked = table.get(key.toString())\n              if (marked === undefined){\n                console.log([stateLine,stateColumn], symbol, [t1,t2])\n              }\n              flag = flag || marked\n              table.set([stateLine, stateColumn].toString(), marked)\n\n              if(marked) break\n            }\n          }\n        }\n      }\n\n    }\n\n    console.log(\"2:\",table)\n\n\n    const dset = new DisjointSet(this.states)\n\n    for (let [line_column, mark] of table.entries()){\n      let [line, column] = line_column.split(',')\n      if(!mark){\n        dset.union(line ,column)\n      }\n    }\n\n    this.states = dset.get().map(states => (\n      states.reduce((name, state)=> name ? name+\"^\"+state : state, '')\n    ))\n\n    this.initialState = this.states.filter(state => state.split(\"^\").includes(this.initialState))[0]\n\n    this.terminals = this.states.filter(state => {\n      let finded = false\n      for(let old_terminal of this.terminals){\n        finded = finded || state.split(\"^\").includes(old_terminal)\n      }\n      return finded\n    })\n\n    this._updateProductions()\n\n    this.alphbet = [\"\", ...this.alphbet]\n    this.print()\n  }\n\n  protected _updateProductions(){\n    let newProductions:any = {}\n\n    for(let [old_state, production] of Object.entries(this.productions)){\n      if (!newProductions[this._findUnion(old_state)]){\n        newProductions[this._findUnion(old_state)] = production\n      }else{\n        newProductions[this._findUnion(old_state)] = {\n          ...newProductions[this._findUnion(old_state)],\n          ...this.productions[this._findUnion(old_state)]\n        }\n      }\n    }\n\n    for(let state of this.states){\n      if(newProductions[state])\n      for(let s of Object.keys(newProductions[state])){\n        newProductions[state][s] = this._findUnion(newProductions[state][s])\n      }\n    }\n\n    this.productions = newProductions\n  }\n\n  protected _findUnion(old_state:string){\n    return this.states.filter(state => state.split(\"^\").includes(old_state))[0]\n  }\n\n  protected _addReject(){\n    this.states = [...this.states, \"REJECT\"]\n\n    for(let start of this.states){\n      if(!this.productions[start]){\n        this.productions[start] = {}\n      }\n\n      for( let symbol of this.alphbet){\n        if(!this.productions[start][symbol]){\n          this.productions[start] = {\n            ...this.productions[start],\n            [symbol]: \"REJECT\"\n          }\n        }\n      }\n\n    }\n  }\n}\n","import './style.css'\n\nimport React from 'react'\nimport { useState } from 'react'\nimport swal from 'sweetalert'\n\nimport Afd from '../../core/Afd'\nimport { parseJSON, parseWordTupleList } from '../../core/utils'\n\ndeclare global {\n  var __AFD__: Afd;\n}\n\ninterface IEditorProps{\n  grammarState: [string, Function]\n}\n\nexport default function Editor(props:IEditorProps) {\n  const [grammar, setGrammar] = props.grammarState\n  const [wordList, setWordList] = useState([\n    {\n      word: '',\n      result: 'disabled',\n      history: []\n    }\n  ])\n  const [listFilter, setListFilter] = useState([['','']])\n\n  function handleNewFile(event:React.ChangeEvent<HTMLInputElement>) {\n    event.preventDefault()\n\n    const file = event.target.files[0];\n\n    if (file) {\n      try {\n        const reader = new FileReader();\n\n        reader.onloadend= () => {\n          setGrammar(reader.result as string)\n        }\n\n        reader.readAsText(file);\n      } catch (err) {\n        swal('Erro', err.message, \"error\")\n      }\n\n    }else {\n      swal(\"Nenhum arquivo\")\n    }\n  }\n\n  function handleGrammarChange (event:React.ChangeEvent<HTMLTextAreaElement>) {\n    event.preventDefault()\n\n    setGrammar(event.target.value)\n  }\n\n  function executeFor(key:number, newWord:string):void{\n    setWordList(wordList.map((item, index)=>{\n      if(window.__AFD__){\n        if(index === key){\n          window.__AFD__.history = []\n          if(window.__AFD__.run(newWord)){\n            return {\n              word: newWord,\n              result: 'success',\n              history: window.__AFD__.history\n            }\n          }else{\n            return {\n              word: newWord,\n              result: 'error',\n              history: window.__AFD__.history\n            }\n          }\n        }else{\n          return item\n        }\n\n      }else{\n        return {\n          word: '',\n          result: 'disabled',\n          history: []\n        }\n      }\n    }))\n  }\n\n  function createAfd(grammar:string){\n    try{\n      window.__AFD__ = new Afd(parseJSON(grammar))\n      setWordList(wordList.map(() => ({\n        word: '',\n        result: window.__AFD__.run('') ? 'success' : 'error',\n        history: window.__AFD__.history\n      })))\n    }catch(err){\n      swal(\"Erro na criação\", err.message, \"error\")\n    }\n  }\n\n  function addInput(){\n    setWordList([\n      ...wordList,\n      {\n        word: '',\n        result: window.__AFD__.run('') ? 'success' : 'error',\n        history: window.__AFD__.history\n      }\n    ])\n  }\n\n  function closeInput(key:number){\n    setWordList(wordList.filter((_word, index) => key !== index))\n  }\n\n  interface IInputMessageProps{\n    result: string\n  }\n\n  const InputMessage = (props:IInputMessageProps) => {\n    switch(props.result){\n      case(\"error\"):\n        return (\n          <span  className=\"nes-badge\">\n            <span className=\"is-error\">REJEITA</span>\n          </span>\n        )\n      case(\"success\"):\n        return (\n          <span className=\"nes-badge\">\n            <span className=\"is-success\">ACEITA</span>\n          </span>\n        )\n      case(\"disabled\"):\n        return (\n          <span className=\"nes-badge\">\n            <span className=\"is-dark\">_</span>\n          </span>\n        )\n    }\n  }\n\n  interface IHistoryMessageProps {\n    lastRound: [string, string, string|undefined]\n  }\n\n  const HistoryMessage = (props:IHistoryMessageProps) => {\n    const symbol = props.lastRound[1]\n    const lastState = props.lastRound[2]\n\n    if(window.__AFD__.alphbet.includes(symbol)){\n      if(lastState){\n        if(window.__AFD__.terminals.includes(lastState)){\n          return (<p className=\"nes-text is-success\">Palavra aceita</p>)\n        }else{\n          return (<p className=\"nes-text is-error\">Estado final não é terminal</p>)\n        }\n      }else{\n        return (<p className=\"nes-text is-error\">Produção indefinida</p>)\n      }\n    }else{\n      return (<p className=\"nes-text is-error\">Simbolo não pertence ao alfabeto</p>)\n    }\n\n  }\n\n  function handleWordTupleList(event:React.ChangeEvent<HTMLInputElement>) {\n    event.preventDefault()\n\n    const file = event.target.files[0];\n\n    if (file) {\n      try {\n        const reader = new FileReader();\n\n        reader.onloadend= () => {\n          setListFilter(parseWordTupleList(reader.result as string) || [['','']])\n        }\n\n        reader.readAsText(file);\n      } catch (err) {\n        swal('Erro', err.message, \"error\")\n      }\n\n    }else {\n      swal(\"Nenhum arquivo\")\n    }\n  }\n\n  return (\n    <section id=\"editor\">\n      <div className=\"editor__group1 nes-container is-rounded\">\n        <nav className=\"editor__controlsBar\">\n          <div className=\"editor__editorControl\">\n            <label className=\"nes-btn is-primary\">\n              <span>\n                Selecione um arquivo\n              </span>\n              <input\n                type=\"file\"\n                className=\"editor__fileInput is-primary\"\n                onChange={handleNewFile}\n              />\n            </label>\n          </div>\n          <div className=\"editor__editorControl\">\n            <input\n              type=\"button\"\n              value=\"Criar automato\"\n              className=\"nes-btn is-success\"\n              onClick={() => createAfd(grammar)}\n            />\n          </div>\n        </nav>\n        <div className=\"editor__textEditor nes-field\">\n          <textarea\n            name=\"editor\"\n            cols={90}\n            rows={20}\n            value={grammar}\n            onChange={handleGrammarChange}\n            spellCheck=\"false\"\n            className=\"nes-textarea\"\n            wrap=\"soft\"\n          />\n        </div>\n      </div>\n      <div className=\"editor__group2 nes-container is-rounded\">\n        <input\n          type=\"button\"\n          value=\"Add input\"\n          className={`nes-btn is-${window.__AFD__ ? \"warning\" : \"disabled\"}`}\n          onClick={() => window.__AFD__? addInput() : false}\n        />\n        {\n          wordList.map((item, index)=>(\n            <div key={index} className=\"editor__wordsInputs nes-container is-rounded\">\n              <div className=\"editor__inputHeader\">\n                <InputMessage result={item.result} />\n                <button\n                  className=\"nes-btn is-error\"\n                  onClick={() => closeInput(index)}\n                >X</button>\n              </div>\n              <input\n                type=\"text\"\n                value={item.word}\n                onChange={(e) => executeFor(index, e.target.value)}\n                className={`nes-input is-${item.result}`}\n                placeholder={window.__AFD__?\"Palavra vazia\":\"Crie um Automato\"}\n              />\n              <details style={{marginTop:'1rem'}}>\n                <summary>Histórico</summary>\n                <div\n                  className=\"nes-container is-rounded is-dark\"\n                  style={{textAlign:\"center\"}}>\n                  {\n                    item.history.map(([currenteState, simbol, newState], index) => (\n                      <p key={index}>\n                        <span className=\"nes-text is-warning\">{`${index+1}) `}</span>\n                        <strong className=\"nes-text is-success\">{currenteState}</strong>\n                        {newState ? (\n                          <>\n                            |<span className=\"nes-text is-primary\">{`(${simbol})`}</span>\n                            |<strong className=\"nes-text is-success\">{newState}</strong>\n                          </>\n                        ) : (\n                          <>\n                            |<span className=\"nes-text is-error\">{`(${simbol})`}</span>\n                          </>\n                        )\n                        }\n                      </p>\n                    ))\n                  }\n                  {\n                    item.history.length ? <HistoryMessage lastRound={item.history[item.history.length -1]}/> : ''\n                  }\n                  </div>\n              </details>\n            </div>\n            )\n          )\n        }\n\n      </div>\n      <div className=\"editor__group3 nes-container is-rounded\">\n        <div className=\"editor__editorControl\">\n          <label className={`nes-btn is-${window.__AFD__ ? \"primary\" : \"disabled\"}`}>\n            <span>\n              Lista de duplas de palavras\n            </span>\n            <input\n              type=\"file\"\n              className={`editor__fileInput`}\n              onChange={ window.__AFD__ ? handleWordTupleList : ()=>false }\n            />\n          </label>\n        </div>\n        <div className=\"editor__wordTupleView\">\n          <div className=\"editor__listView lists nes-container is-rounded is-dark\">\n            <h3>Input</h3>\n            <ul className=\"is-circle\">\n              {\n                listFilter.map((wordTuple, index) => {\n                  if (window.__AFD__){\n                    if(window.__AFD__.run(wordTuple[0]) && window.__AFD__.run(wordTuple[1])) {\n                      return (\n                        <li className=\"nes-text is-primary\"\n                          key={index}\n                        >{`(${wordTuple[0]}, ${wordTuple[1]})`}</li>\n                      )\n                    }else{\n                      return (\n                        <li className=\"nes-text is-error\"\n                          key={index}\n                        >{`(${wordTuple[0]}, ${wordTuple[1]})`}</li>\n                      )\n                    }\n                  }else{\n                    return false\n                  }\n\n\n                })\n              }\n            </ul>\n          </div>\n\n          <div className=\"editor__listView lists nes-container is-rounded is-dark\">\n          <h3>Output</h3>\n            <ul className=\"is-circle\">\n              {\n                listFilter\n                  .filter(wordTuple => (\n                    window.__AFD__ ?\n                    window.__AFD__.run(wordTuple[0]) &&\n                    window.__AFD__.run(wordTuple[1]) :\n                    false\n                  ))\n                  .map((wordTuple, index) => {\n                    return (\n                      <li className=\"nes-text is-success\"\n                        key={index}\n                      >{`(${wordTuple[0]}, ${wordTuple[1]})`}</li>\n                    )\n                  })\n              }\n            </ul>\n          </div>\n        </div>\n      </div>\n    </section>\n  )\n}\n","import swal from 'sweetalert'\n\nexport function parseJSON(grammar:string){\n  interface IObj{\n    name:string,\n    states:Array<string>,\n    alphbet:Array<string>,\n    productions:any,\n    initialState:string,\n    terminals:Array<string>\n  }\n\n  const obj:IObj = {\n    name:'',\n    states:[],\n    alphbet:[],\n    productions:{},\n    initialState:'',\n    terminals:[]\n  }\n  try{\n    const lines = grammar.split(\"\\n\")\n    let [afd_name, definition] = lines[0].split(\"=({\")\n    obj.name = afd_name.trim()\n\n    let [states, rest1] = definition.split('},{')\n    obj.states = states.split(\",\").map(item => item.trim())\n\n    let [alphbet, rest2] = rest1.split('},')\n    obj.alphbet = alphbet.split(',').map(item => item.trim())\n\n    let [prog_name_initial, rest3] = rest2.split(',{')\n\n    let [prog_name, initial] = prog_name_initial.split(',')\n    obj.initialState = initial.trim()\n\n    let terminals = rest3.slice(0, rest3.length-2).split(',')\n    obj.terminals = terminals.map(item => item.trim())\n\n    if(prog_name === lines[1]){\n      for(let line of lines.slice(2)){\n        if(!line.length){\n          continue\n        }\n        line = line.trim()\n        let [state_symbol, production] = line.slice(1).split(\")=\").map(item => item.trim())\n        let [state, symbol] = state_symbol.split(',').map(item => item.trim())\n\n        if (obj.productions[state]){\n          obj.productions[state][symbol] = production\n        }else{\n          obj.productions[state] = {[symbol]: production}\n        }\n      }\n    }else{\n      throw new Error(\"Nome das produções errado\")\n    }\n\n    return JSON.stringify(obj)\n  }catch(err){\n    throw new Error(`Formato de entrada errado`)\n  }\n}\n\nexport function parseWordTupleList(text:string){\n  try{\n    return text\n          .trim()\n          .split(\"\\n\")\n          .map(tuple => {\n            tuple = tuple.trim()\n            if(tuple.match(/\\(.+,.+\\)/) && !tuple.match(/\\(.+,.*,\\)/)){\n              return tuple\n                      .slice(1, tuple.length-1)\n                      .split(\",\")\n                      .map(word => word.trim())\n            }else {\n              throw new Error(\"entrada errada\")\n            }\n          })\n  }catch(err){\n    swal(\"Erro Formato\", err.message, \"error\")\n  }\n}\n","import React from 'react';\nimport {useState} from 'react';\nimport Editor from './components/Editor'\nimport './App.css';\n\nfunction App() {\n  const grammarState = useState(``)\n\n  return (\n    <main className=\"App\">\n      <Editor\n        grammarState={grammarState}\n      />\n    </main>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}